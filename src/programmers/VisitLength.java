package programmers;public class VisitLength {    //캐릭터가 이동한 거리를 표시할 2차원 배열    static int[][] map = new int[11][11];    // 이전에 어떤 방향으로 배열로 이동했는지 기억할 2차원 배열    static boolean[][][] visit = new boolean[11][11][4];    // UP, DOWN, LEFT, RIGHT로 이동하게 명령어 배열    static int[][] d = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};    public int solution(String dirs) {        // 총 이동거리        int answer = 0;        // 최초 캐릭터 위치        int row = 5, col = 5;        // dirs 길이만큼 명령어를 실행한다.        for (int i = 0; i < dirs.length(); i++) {            // 명령어 배열 인덱스의 끝, arrow는 캐릭터가 이동할 방향, oppo는 이동할 방향의 반대방향이다.            int arrow = 3;            int oppo = 3;            // switch-case를 통해 이동방향과 그에 반대되는 방향을 지정한다.            switch (dirs.charAt(i)) {                case 'U':                    arrow -= 3;                    oppo -= 2;                    break;                case 'D':                    arrow -= 2;                    oppo -= 3;                    break;                case 'L':                    arrow -= 1;                    oppo -= 0;                    break;                case 'R':                    arrow -= 0;                    oppo -= 1;                    break;            }            // 다음 움직일 방향을 초기화한다.            int nRow = row + d[arrow][0];            int nCol = col + d[arrow][1];            // map의 범위를 넘지 않고, 새로 움직일 방향과, 반대되는 방향을 방문한 적이 없다면            // 1. 방문 처리            // 2. 현재 위치 업데이트            // 3. 방문 거리 ++            if (nRow >= 0 && nRow < 11 && nCol >= 0 && nCol < 11) {                if (!visit[nRow][nCol][arrow] && !visit[row][col][oppo]) {                    visit[nRow][nCol][arrow] = true;                    row = nRow;                    col = nCol;                    answer++;                    // 아닌 경우에는 이동은 되었지만 최초 움직인 방향이 아니기 때문에 현재 위치만 업데이트                } else {                    row = nRow;                    col = nCol;                }            }        }        return answer;    }}