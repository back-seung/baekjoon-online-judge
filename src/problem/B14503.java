package problem;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;/*1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우,    1. 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.    2. 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우    1. 반시계 방향으로 90도 회전한다.    2. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.    3. 1번으로 돌아간다. */// 0, 1, 2, 3// 북,동,남,서public class B14503 {    static int N, M, count;    static int r, c, d;    static int[][] map;    static int[][] D = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st = new StringTokenizer(br.readLine());        N = Integer.parseInt(st.nextToken());        M = Integer.parseInt(st.nextToken());        map = new int[N][M];        st = new StringTokenizer(br.readLine());        r = Integer.parseInt(st.nextToken());        c = Integer.parseInt(st.nextToken());        d = Integer.parseInt(st.nextToken());        count = 1;        // 맵 초기화        for (int i = 0; i < N; i++) {            st = new StringTokenizer(br.readLine());            for (int j = 0; j < M; j++) {                map[i][j] = Integer.parseInt(st.nextToken());            }        }        DFS(r, c, d);        System.out.println(count);    }    public static void DFS(int row, int col, int direction) {        map[row][col] = -1;        for (int i = 0; i < 4; i++) {            direction = (direction + 3) % 4;            int nRow = row + D[direction][0];            int nCol = col + D[direction][1];            if (nRow >= 0 && nRow < N && nCol >= 0 && nCol < M && map[nRow][nCol] == 0) {                count++;                DFS(nRow, nCol, direction);                return;            }        }        int moveBack = (direction + 2) % 4;        int bRow = row + D[moveBack][0];        int bCol = col + D[moveBack][1];        if (bRow >= 0 && bRow < N && bCol >= 0 && bCol < M && map[bRow][bCol] != 1) {            DFS(bRow, bCol, direction);        }    }}