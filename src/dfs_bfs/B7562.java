package dfs_bfs;import java.io.*;import java.util.*;public class B7562 {    static int TC, L;    static boolean[][] visit;    static int[][] map;    static int[][] move = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {1, -2}, {2, -1}};    static int startR, startC, endR, endC;        public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st;        TC = Integer.parseInt(br.readLine());        for (int i = 0; i < TC; i++) {            L = Integer.parseInt(br.readLine());            st = new StringTokenizer(br.readLine());            startR = Integer.parseInt(st.nextToken());            startC = Integer.parseInt(st.nextToken());            st = new StringTokenizer(br.readLine());            endR = Integer.parseInt(st.nextToken());            endC = Integer.parseInt(st.nextToken());            if (startR == endR && startC == endC) {                System.out.println(0);                continue;            }            visit = new boolean[L][L];            visit[startR][startC] = true;            map = new int[L][L];            map[startR][startC] = 1;            BFS(startR, startC);        }    }    public static void BFS(int row, int col) {        Queue<int[]> queue = new LinkedList<>();        queue.add(new int[]{row, col});        visit[row][col] = true;        while (!queue.isEmpty()) {            int[] rc = queue.poll();            row = rc[0];            col = rc[1];            if (row == endR && col == endC) {                System.out.println(map[endR][endC] - 1);            }            for (int i = 0; i < move.length; i++) {                int newRow = row + move[i][0];                int newCol = col + move[i][1];                if (newRow >= 0 && newRow < L && newCol >= 0 && newCol < L) {                    if (!visit[newRow][newCol] && map[newRow][newCol] == 0) {                        queue.add(new int[]{newRow, newCol});                        map[newRow][newCol] = map[row][col] + 1;                        visit[newRow][newCol] = true;                    }                }            }        }    }}