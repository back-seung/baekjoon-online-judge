package dfs_bfs;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;import java.util.StringTokenizer;public class B4963 {    static int W, H;    static boolean[][] map;    static int landCount;    static int[][] move = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};    static class Node {        int row;        int col;        public Node(int row, int col) {            this.row = row;            this.col = col;        }    }    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st;        while (true) {            landCount = 0;            st = new StringTokenizer(br.readLine());            W = Integer.parseInt(st.nextToken());            H = Integer.parseInt(st.nextToken());            if (W == 0 && H == 0) {                break;            }            map = new boolean[H][W];            for (int i = 0; i < H; i++) {                st = new StringTokenizer(br.readLine());                for (int j = 0; j < W; j++) {                    map[i][j] = st.nextToken().equals("1");                }            }////            for (int i = 0; i < H; i++) {//                for (int j = 0; j < W; j++) {//                    System.out.print(map[i][j] + " ");//                }//                System.out.println();//            }//            System.out.println();            // DFS 작성            for (int i = 0; i < H; i++) {                for (int j = 0; j < W; j++) {                    if (map[i][j]) {                        DFS(i, j);                    }                }            }            System.out.println(landCount);        }    }    public static void DFS(int row, int col) {        Stack<Node> stack = new Stack<>();        stack.push(new Node(row, col));        landCount++;        while (!stack.isEmpty()) {            Node node = stack.pop();            row = node.row;            col = node.col;            map[row][col] = false;            for (int i = 0; i < move.length; i++) {                int nRow = row + move[i][0];                int nCol = col + move[i][1];                if (nRow >= 0 && nRow < H && nCol >= 0 && nCol < W) {                    if (map[nRow][nCol]) {                        map[nRow][nCol] = false;                        stack.push(new Node(nRow, nCol));                    }                }            }        }    }}