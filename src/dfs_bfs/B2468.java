package dfs_bfs;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;import java.util.StringTokenizer;public class B2468 {    static int N;    static int[] height = new int[101];    static int[][] map;    static boolean[][] visit;    static int[][] move = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};    static int max = 1;    static int safe;    static int safeMax = 1;    static class Node {        int row;        int col;        public Node(int row, int col) {            this.row = row;            this.col = col;        }    }    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        N = Integer.parseInt(br.readLine());        map = new int[N][N];        StringTokenizer st;        for (int i = 0; i < N; i++) {            st = new StringTokenizer(br.readLine());            for (int j = 0; j < N; j++) {                int heigth = Integer.parseInt(st.nextToken());                map[i][j] = heigth;                max = Math.max(max, heigth);            }        }        for (int i = 1; i < max; i++) {            visit = new boolean[N][N];            for (int j = 0; j < N; j++) {                for (int k = 0; k < N; k++) {                    visit[j][k] = map[j][k] > i;                }            }            safe = 0;            for (int row = 0; row < N; row++) {                for (int col = 0; col < N; col++) {                    if (visit[row][col]) {                        DFS(row, col);                        safe++;                    }                }            }            safeMax = Math.max(safeMax, safe);        }        System.out.println(safeMax);    }    public static void DFS(int row, int col) {        Stack<Node> stack = new Stack<>();        stack.push(new Node(row, col));        while (!stack.isEmpty()) {            Node node = stack.pop();            row = node.row;            col = node.col;            visit[row][col] = false;            for (int i = 0; i < move.length; i++) {                int nRow = row + move[i][0];                int nCol = col + move[i][1];                if (nRow >= 0 && nRow < N && nCol >= 0 && nCol < N) {                    if (visit[nRow][nCol]) {                        stack.push(new Node(nRow, nCol));                    }                }            }        }    }}