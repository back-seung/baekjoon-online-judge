package dfs_bfs;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class B1926RE {    static int N, M, now, paints, max; // 세로, 가로, 현재 그림 면적, 총 그림 개수, 최대 면적    static boolean[][] map;     // 도화지    static int[][] D = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 상, 하, 좌, 우 이동 델타 그래프    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st = new StringTokenizer(br.readLine());        N = Integer.parseInt(st.nextToken());        M = Integer.parseInt(st.nextToken());        map = new boolean[N][M];        now = 0;        max = 0;        for (int i = 0; i < N; i++) {            st = new StringTokenizer(br.readLine());            for (int j = 0; j < M; j++) {                map[i][j] = Integer.parseInt(st.nextToken()) == 1 ? true : false;            }        }        // 입력부 마무리        for (int i = 0; i < N; i++) {            for (int j = 0; j < M; j++) {                if (map[i][j]) {    // 도화지를 순회하면서 칠해진 부분(1)이 있다면 DFS 진입                    paints++;       // 전체 그림 개수 1개 추가                    now = 1;        // 현재 면적은 1, 이후 DFS 에서 면적을 계속 넓혀나감                    DFS(i, j);      // DFS 진입                }            }        }        System.out.println(paints);        System.out.println(max);    }    public static void DFS(int row, int col) {        map[row][col] = false;      // 방문 처리        for (int i = 0; i < D.length; i++) {            int nRow = row + D[i][0];   // 세로 방향            int nCol = col + D[i][1];   // 가로 방향            // 도화지의 면적 내부이면서, 이어지는 그림이 있다면 면적의 크기를 더하고, DFS로 추가 순회            if (nRow >= 0 && nCol >= 0 && nRow < N && nCol < M && map[nRow][nCol]) {                now++;                DFS(nRow, nCol);            }        }        max = Math.max(now, max);   // 현재 그림의 면적이 이전 그림의 면적보다 큰지 비교    }}